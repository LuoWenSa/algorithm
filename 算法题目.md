# 数组系列

## 两个数组的交集(350)

给定两个数组，编写一个函数来计算它们的交集。

**示例 1:**

```c++
输入: nums1 = [1,2,2,1], nums2 = [2,2]

输出: [2,2]
```

**示例 2:**

```c++
输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]

输出: [4,9]
```

### 题解：

首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的**映射题（map映射）**，为什么可以这样看呢，因为**我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了<元素,出现次数>**。剩下的就是顺利成章的解题。

### 题目进阶

题目在进阶问题中问道：如果给定的数组已经排好序呢？你将如何优化你的算法？我们分析一下，假如两个数组都是有序的，分别为：arr1 = [1,2,3,4,4,13]，arr2 = [1,2,3,9,10]

#### 题解：

对于两个已经排序好数组的题，我们可以很容易想到使用双指针的解法~

https://www.geekxh.com/1.0.%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97/001.html#_04%E3%80%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E7%AD%94

## 最长公共前缀(14)

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，则返回""

**示例1:**

```c++
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例2:**

```c++
输入: ["dog","racecar","car"]
输出: ""
```

### 题解：

> 我们要想寻找最长公共前缀，那么**首先这个前缀是公共的，我们可以从任意一个元素中找到它**。假定我们现在就从一个数组中寻找最长公共前缀，那么首先，我们可以将第一个元素设置为基准元素x0。假如数组为["flow","flower","flight"]，flow就是我们的基准元素x0。

然后我们只需要**依次将基准元素和后面的元素进行比较**（假定后面的元素依次为x1,x2,x3....），**不断更新基准元素，直到基准元素和所有元素都满足最长公共前缀的条件**，就可以得到最长公共前缀。

具体比对过程如下：

- 如果strings.Index(x1,x) == 0，则直接跳过（因为此时x就是x1的最长公共前缀），对比下一个元素。（如flower和flow进行比较）
- 如果strings.Index(x1,x) != 0, 则截取掉基准元素x的最后一个元素，再次和x1进行比较，直至满足string.Index(x1,x) == 0，此时截取后的x为x和x1的最长公共前缀。（如flight和flow进行比较，依次截取出flow-flo-fl，直到fl被截取出，此时fl为flight和flow的最长公共前缀）

![](https://www.geekxh.com/assets/img/1.57270b1c.png)

最后，我们记得处理一下临界条件。如果给定数组是空，即数组长度为0，也说明没有最长公共元素。

## 旋转数组(189)

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**示例 1:**

```c++
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
```

**示例 2:**

```c++
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
```

### 题解：

**常规思想：**

**取余**：若我们需要将数组中的元素向右移动 k 个位置， 那么 k%l (l为数组长度) 的尾部元素会被移动到头部，剩下的元素会被向后移动。

![](https://www.geekxh.com/assets/img/1.c67a662e.png)

**原地翻转的方法思想：**

通过观察我们可以得到，我们要得到最终的结果。**我们只需要将所有元素反转，然后反转前 k 个元素，再反转后面l-k个元素，就能得到想要的结果。**

![](https://www.geekxh.com/assets/img/2.cbeec2a0.png)

