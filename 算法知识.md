# JAVA 算法

1. Java二维数组声明，数组声明可见一斑
   数据类型 数组名 [ ][ ] = new 数据类型[][][ ][ ]

   ```java
   int a[][]=new int[n][3];
   ```

   

2. 通过Math.random()返回一个0到1之间（[0,1)）的double值。

   ```java
   Math.random();
   ```

   











# C算法

## 字符串（字符数组）操作

1. C语言声明字符数组

```c
char str[30] //"字符串"
```

字符数组实际上是一系列字符的集合，也就是字符串（String）。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。

2. 字符数组的输入

```c
scanf("%s", str);
```

3. 字符数组的输出

```c
printf("%s", str);	
```

4. 使用strcmp函数进行比较

```c
#include <stdio.h>
#include <string.h> 
int main(void)
{
	char* str1 = "abc";
	char* str2 = "abc"; 
	if (strcmp(str1, str2) == 0) {		//若两字符串相同返回0
	    printf("str1和str2相同!\n");
	}
	else {
	    printf("str1和str2不相同!\n");
	} 
    return 0;
}
```

<table><tr><td bgcolor=yellow>不能用==，!=,>=,<=比较两个字符串</td></tr></table>

5. 给一个字符数组赋值字符串：

```c
strcpy( a, "abcdefgh");
```

## int,float型的绝对值函数

6. int型的绝对值函数：int abs(int x);
7. float型的绝对值函数：float fabs(float x); 
8. printf中%04d，表示输出时最大宽度为4，右对齐，不足的补0.

## 随机函数rand

```c++
#include <iostream>
#include <cstdlib>      //头文件
#include <ctime>        //头文件
using namespace std;

int main()
{
    srand(time(NULL));  //设置随机数种子
    int a=rand()%3;     //取值范围0，1，2
    cout<<a;
    return 0;
}
```



# C++算法

## 算法注意事项

#### 1.浮点型计算精度问题

题目来源：[2014年蓝桥杯c/c++B组 第六题：奇怪的分式](https://blog.csdn.net/qq_18841761/article/details/108042671)

```c++
#include <iostream>

using namespace std;

int main()
{
    int ct=0;
    double ans1,ans2;
    for(int i=1;i<=9;i++){
        for(int j=1;j<=9;j++){
            if(i==j){
                continue;
            }
            for(int x=1;x<=9;x++){
                for(int y=1;y<=9;y++){
                    if(x==y){
                        continue;
                    }
                    ans1=(double)(i*x)/(j*y);           //该行代码得到答案14，为正确答案
                  //ans1=((double)i/j)*((double)x/y);    ans1所表达的意思一样，但精度有损，该行代码得到答案12
                    ans2=(double)(i*10+x)/(double)(j*10+y);
                    if(ans1==ans2){
                        ct++;
                    }
                }
            }
        }
    }
    cout<<ct;
    return 0;
}
```

#### 2.判断是否为闰年：

```c++
y % 400 == 0 || (y % 4 == 0 && y % 100 != 0)  //1.能被400整除 2.能被4整除但不能被100整除
```

#### 3.计算超时

遍历次数为10的10次方数量级时，程序运行会超时

#### 4.负数在计算机中的存储

注意负数，负数在计算机中是以补码的方式储存的，

比如-1 的原码是【1000 0001】

          反码是【1111 1110】（按位取反）
    
          补码是【1111 1111】（相加）

等同于127的原码，所以对于负数，可以+128后处理。

## 经典算法

#### 求最大公因数（gcd）的方法就是辗转相除法

例1 。求两个正数8251和6105的最大公因数。

（分析：辗转相除→余数为零→得到结果）
以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数

解：8251＝6105×1＋2146

显然8251与6105的最大公因数也必是2146的因数，同样6105与2146的公因数也必是8251的因数，所以8251与6105的最大公因数也是6105与2146的最大公因数。

6105＝2146×2＋1813

2146＝1813×1＋333

1813＝333×5＋148

333＝148×2＋37

148＝37×4＋0

则37为8251与6105的最大公因数。

```c++
int gcd(int a,int b){
    if(a%b==0){
        return b;
    }else{
        return gcd(b,a%b);
    }
}
```

#### 素数的求法

```c++
#include <string>
#include <cmath>
using namespace std;
int prime(int x){
    if(x==2||x==3){
        return 1;
    }
    for(int i=2;i<=sqrt(x);i++){     //重点关注！！！！
        if(x%i==0){
            return 0;
        }
    }
    return 1;

}
int main()
{   int n;
    cin>>n;
    if(prime(n)){
        cout<<"yes";
    }else{
        cout<<"no";
    }
    return 0;
}
```



## 各数据类型取值及范围参考：

![](https://img-blog.csdnimg.cn/20181123112722184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21tazI3X3dvcmQ=,size_16,color_FFFFFF,t_70)

## 奇奇怪怪的格式输入

```c++
2					//表示两行
5 6 8 11 9			//第一行的数据
10 12 9				//第二行的数据
```

```c++
 	//《第一种方法》
	cin>>n;
    cin.get();
    for(int i=0;i<n;i++){
        while((ch=cin.get())!='\n'){
            cin.unget();      //将cin.get()取到的字符放回输入流中
            cin>>k;
        }
    }
```

```c++
	cin >> m;
    for (int i = 0; i < m; i++)
    {
        while (1)
        {
            cin>>t;
            v.push_back(t);		//stl的vector容器
            if (getchar() == '\n')
                break;
        }
    }
```

我像个傻子一样搞了半天字符串去空格，结果一个输入格式就搞定，rubbish

```c++
//输入：
//****     180.90       88折
//。。。。    。。。。    。。。。

cin>>item>>price>>discount;




//tips：不同类型也能输入！！！！！！！！！！！！！！！
string item,discount;
float price;
cin>>item>>price>>discount;
```



#### [🔗：cin的详细用法](https://blog.csdn.net/u011486738/article/details/82284581)

## 二维数组初始化推荐（memset）

导入头文件： C 标准库 - <string.h>

在前面不止一次说过，定义变量时一定要进行初始化，尤其是数组和结构体这种占用内存大的数据结构。在使用数组的时候经常因为没有初始化而产生“烫烫烫烫烫烫”这样的野值，俗称“乱码”。

每种类型的变量都有各自的初始化方法，memset() 函数可以说是初始化内存的“万能函数”，通常为新申请的内存进行初始化工作。它是直接操作内存空间，mem即“内存”（memory）的意思。

```c++
//1.普通初始化
	int dp[l][k]={0};      //失败，只适用于一维数组。
//2.用memset函数初始化
	int dp[l][k];
    memset(dp,0,sizeof(dp));      //成功
//3.直接可以赋值，但是其中的[][]内必须是具体数值，不能带有符号   2021.4.3
	int f[5][9]={{0}};
```



## C++已经定义好的pi (π)值

math.h头文件中有宏定义的pi (π)

<img src="https://images0.cnblogs.com/blog/495014/201402/061128558264529.png" style="zoom:150%;" />

## 字符串输入

c++输入字符串：cin.getline()

1.接收一个字符串，可以接收空格并输出,自动接收一个 ‘\0’

2.cin.getline()实际有三个参数，cin.getline(接收字符串,接收个数，结束字符)
当第三个参数缺省时，系统默认是 ‘\0’

```c++
#include <iostream>
using namespace std;
int main()
{
    char a[2][30];
    char b[30];
    for(int i=0;i<2;i++){
       cin.getline(a[i],30);
    }
    for(int i=0;i<2;i++){
       cout<<a[i]<<endl;
    }
    return 0;
}
```

## c++保留几位小数：

```c++
cout<<fixed<<setprecision(2)<<n;	//头文件 #include <iomanip>
```

## normal:10进制转二进制

```c++
int f(int n){
    if(n==0||n==1){
        return n;
    }
    int a=0,i=0;
    while(n/2!=0){
        a+=(n%2)*(int)pow(10,i);
        n=n/2;
        i++;
    }
    a+=n*(int)pow(10,i);
    return a;
}


//究极无敌版
vector<int> v;   
vector<int>::reverse_iterator it;
void dtob(int n){
    if(n==0){
        v.push_back(n);
    }
    if(n<0){
        n+=128;
    }
    while(n!=0){
        v.push_back(n%2);
        n/=2;
    }
    for(it=v.rbegin();it!=v.rend();it++){
        cout<<*it<<" ";
    }

}
```

## 特殊字符的ASCll码

A:65	a:97

## string类型

string是C++标准库的一个重要的部分，主要用于字符串处理。同时，C++的算法库对string类也有着很好的支持，并且string类还和c语言的字符串之间有着良好的接口。

#### [c++ string类型详解及方法介绍](https://blog.csdn.net/qq_30534935/article/details/82227364?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.baidujs&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.baidujs)

#### string类型作为形参：

```c++
#include <string>
int f(string &s1,string &s2);

int main(){
    string s1,s2;
    f(s1,s2);
    return 0;
}
```
#### string类型，带有空格的输入（getline();）
```c++
string s;
getline(cin,s);
```

#### string类型，不带有空格的输入

```c++
    while(1){    //自己写的
        if(cin.get()=='\n'){
            break;
        }
        cin.unget();
        if(cin.get()==' '){
            ;
        }else{
            cin.unget();
            cin>>c;
            s+=c;
        }

    }
```



#### substr

```c++
#include<string>
#include<iostream>
using namespace std;
int main()
{
　　string s("12345asdf");
　　string a = s.substr(0,5);     //获得字符串s中从第0位开始的长度为5的字符串
    //s=s.substr(0,5);           自己截自己
    //s.substr(5);               从下标为5的元素开始截取，直至最后，ans："asdf"
　　cout << a << endl;
}
```

2021.1.31的我可太懒了，后续详细补充吧。。。

#### find函数

string中find()返回值是字串在母串中的位置（下标记录）为字串第一个字符在母串中的下标，如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）

```c++
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string s="lewis";
    string s1;
    cin>>s1;
    if(s.find(s1)==s.npos){
        cout<<"false";
    }else{
        cout<<"true";
    }
    return 0;
}
```



## C++栈:< stack >

 1.操作

```c++
#include< stack > //使用标准库的栈时, 应包含相关头文件，在栈中应包含头文件： 
stack< int > s;	  //初始化栈
s.empty();         //如果栈为空则返回true, 否则返回false;
s.size();          //返回栈中元素的个数
s.top();           //返回栈顶元素, 但不删除该元素
s.pop();           //弹出栈顶元素, 但不返回其值
s.push();          //将元素压入栈顶
```
#### 用栈实现10进制转16进制

2. 用栈实现10进制转16进制

```c++
#include <iostream>
#include <stack>
using namespace std;
int main()
{
    stack<int> mystack;
    char a[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
    long n;
    cin>>n;
    do{
       mystack.push(n%16);
       n/=16;
    }while(n!=0);
    while(!mystack.empty()){
        cout<<a[mystack.top()];
        mystack.pop();
    }
    return 0;
}
```
#### 用栈实现10进制转2进制

3. 用栈实现10进制转2进制

```c++
#include <iostream>
#include <stack>
using namespace std;
int main()
{
    stack<int> mystack;
    long n;
    cin>>n;
    do{                 //用do率先执行，考虑到当n==0的情况
       mystack.push(n%2);
       n/=2;
    }while(n!=0);
    while(!mystack.empty()){
        cout<<mystack.top();
        mystack.pop();
    }
    return 0;
}
```

#### 十六进制转换为八进制（十万位的十六进制）

```c++
#include <iostream>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <stack>
using namespace std;
int main()
{
    int n;
    stack<int> s;
    cin>>n;
    cin.get();
    char str[100008],strEr[400008];
    while(n--){
        cin.getline(str,100008);
        int k=0;
        //将16进制转化为2进制
        for(int i=strlen(str)-1;i>=0;i--)
        {
             int a;
             if(str[i]>='A'&&str[i]<='F')
                   a=str[i]-'A'+10;//当所输入为A~F时，所输入字母减去A再加上10 便是所表示的10进制数。
                else
                   a=str[i]-48;//当输入为0~9时直接减去48或'0'就是相应的整数。
            for(int j=0;j<4;j++)
            {
                strEr[k++]=a%2+'0';
                a=a/2;
            }
        }

        while(strEr[k-1]=='0'){
            k--;
        }
        int r=0;
        int ct=0;
        for(int j=0;j<k;j++){  //二进制转八进制
            if(ct==3){
                ct=0;
                s.push(r);
                r=0;
            }
            r+=(int)(strEr[j]-'0')*(int)pow(2,ct);
            ct++;
        }
        s.push(r);

        while(s.empty()!=true)
        {
            cout<<s.top();
            s.pop();
        }
        cout<<endl;
    }
    return 0;
}
```

#### [求三个数最小公倍数的简单贪心算法](https://blog.csdn.net/wr132/article/details/43538151)

## C++算法：< algorithm >

#### 全排列枚举：next_permutation();

```c++
	#include <algorithm>			//头文件	

	......

	int a[]={1,2,3,4,5,6,7,8,9};
    sort(a,a+9);					//记得用sort排序，不然全排列后可能会丢失一部分排序结果   (如果升序的话没必要sort)
    do{
		......
            
    }while(next_permutation(a,a+9));




	//不会重复
例如int a[3]={0,0,1};全排列，
    正常情况：{0,0,1},{0,1,0},{0,0,1},{0,1,0},{1,0,0},{1,0,0}
	next_permutation:{0,0,1},{0,1,0},{1,0,0}
```

#### sort():排序

1. 对数组排序：sort(a,a+n);

2. 对容器排序：sort(a.begin(),a.end());

3. 对结构体自定义排序：

   ```c++
   bool com(const stu a,const stu b){
       return a.score>b.score; //按分数降序排序
   }
   ```

   

## C++容器：< vector >

2021.2.4的我有点懒吖。。所以之后再慢慢补充
#### [🔗：c++vector的详细用法](https://blog.csdn.net/wkq0825/article/details/82255984?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242)

#### 迭代器（vector < ElemType >::iterator）

```c++
//正向迭代器 normal situation
    vector<char>::iterator it;
    for(it=v.begin();it!=v.end();it++){
        cout<<*it;
    }
```



```c++
//反向迭代器
vector<char>::reverse_iterator it;
    for(it=v.rbegin();it!=v.rend();it++){
        cout<<*it;
    }
```

#### 插入 insert()

| iterator insert(pos,elem) | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
| ------------------------- | ------------------------------------------------------------ |
|                           |                                                              |

```c++
    vector<int>::iterator it;
    for(it=v.begin();it!=v.end()-1;it++){
        cout<<*it<<" ";
        if(*it+d==*(it+1)){
            continue;
        }else{
            it=v.insert(it+1,*it+d);   //自行领会 蓝桥杯2019-8
            it--;
        }
    }
```



## 动态规划

#### 初认dp

简单地采用把大问题分解成子问题，并综合子问题的解导出大问题的解的方法，问 题求解耗时会按问题规模呈幂级数增加。通常引入一个数组求解，不管它们是否对最终解有用，把所有子问题的解存于该数组中，这就是 动态规划法所采用的基本方法。
动态规划的实质是分治思想和解决冗余，因此，动态规划是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免计算重复的子问题，以解决最优化问题的算法策略。

<table><tr><td bgcolor=yellow>要点：1.分而治之.      2.找出状态转移方程</td></tr></table>

#### dp入门级试题

2013年蓝桥杯B组省赛第3题：

小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级!

站在台阶前，他突然又想着一个问题：

如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？

请你利用计算机的优势，帮助小明寻找答案。

要求提交的是一个整数。
注意：不要提交解答过程，或其它的辅助说明文字

```c++
#include <iostream>

using namespace std;

int ct=0;		//定义全局变量，可改
				//const int ct=0;  定义只读的全局变量
				//extern int ct=0; 定义可修改的的全局变量
void dfs(int n,int c){
    if(n==39&&(c%2==0)){
        ct++;
        return;
    }else if(n>39){
        return;
    }else{
        dfs(n+1,c+1);	//不能写成dfs(n++,c++); 会导致return后的n和c值改变
        dfs(n+2,c+1);   //不能写成dfs(n+=2,c++); 会导致return后的n和c值改变
    }
}
int main()
{
    dfs(0,0);
    cout<<ct;
    return 0;
}
```

#### dp常规试题

##### 蓝桥杯2016-7 剪邮票

<font color='red'> dfs检测连通性（经典算法） </font>

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
void dfs(int b[3][4],int i,int j){  //在二维数组中检测连通性（经典算法）
    if(i>=3||i<0||j>=4||j<0){   //超出界限
        return;
    }
    if(b[i][j]==0){
        return;
    }
    if(b[i][j]==1){
        b[i][j]=0;
    }
    dfs(b,i+1,j);
    dfs(b,i-1,j);
    dfs(b,i,j+1);
    dfs(b,i,j-1);
}
int main()
{
    int a[12]={0,0,0,0,0,0,0,1,1,1,1,1};
    int b[3][4];
    int c=0,ct=0;
    //memset(b,0,sizeof(b));
    do{

        for(int i=0;i<3;i++){    //将一维数组映射到二维数组
            for(int j=0;j<4;j++){
                b[i][j]=0;
                if(a[i*4+j]==1){
                    b[i][j]=1;
                }
            }
        }
        for(int i=0;i<3;i++){    //在二维数组中检测连通性（经典算法）
            for(int j=0;j<4;j++){
                if(b[i][j]==1){  //每个是1的地方开始深搜
                    dfs(b,i,j);
                    ct++;
                }
            }
        }
        if(ct==1){
            c++;
        }
        ct=0;
    }while(next_permutation(a,a+12));
    cout<<c;
    return 0;
}
```



#### dp递归与回溯

```c++
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择     //此行就是回溯的体现，退回先前状态，类似于艾克大招
//蓝桥杯2015-7牌型种数
#include <iostream>

using namespace std;
int n=0;
//void dfs(int a[],int i){       思路正确，但运算次数为10的10次方数量级，导致程序超时，不可取
//    if(i==13){
//        n++;
//        return;
//    }
//    for(int j=1;j<=13;j++){
//        if(a[j]==4){
//            continue;
//        }else{
//            a[j]++;
//            dfs(a,i+1);
//            a[j]--;
//        }
//    }
//}



void dfs(int p13,int i){     //把十三张牌数（0，1，2，3，4）分配给13个不同点数
    if(p13==13&&i!=13){
        return;
    }
    if(p13==13&&i==13){
        n++;
        return;
    }
    if(i==13){
        n++;
        return;
    }
    for(int j=0;j<=4;j++){
        i+=j;
        p13++;
        dfs(p13,i);
        i-=j;
        p13--;     //回溯
    }
}
int main()
{
//    int a[14]={0};
//    dfs(a,0);
    dfs(0,0);
    cout<<n;

    return 0;
}
```



#### [有点难度：蓝桥杯 ALGO-3:K好数](https://blog.csdn.net/selaotou11/article/details/104716314)

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int mod=1000000007;
int main()
{
    int k,l,ct=0;
    cin>>k>>l;
    if(k==1){
        cout<<0<<endl;
        return 0;
    }

    int n=k;
    int dp[l][k];
    memset(dp,0,sizeof(dp));
    for(int i=0;i<l;i++){
        for(int j=0;j<k;j++){
                if(i==0){
                    dp[i][j]=1;
                }else{
                    while(!((--n)<0)){
                        if(n-1==j||n+1==j){
                            continue;
                        }else{
                            dp[i][j]+=dp[i-1][n];
                            dp[i][j]%= mod; //小心指数爆炸
                        }
                    }
                }
            n=k;
        }
    }
    for(int i=1;i<k;i++){
        ct+=dp[l-1][i];
        ct%=mod;
    }
    cout<<ct<<endl;
    return 0;
}
```

## 二进制枚举算法

某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪：
每位选手需要回答10个问题（其编号为1到10），越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。
每位选手都有一个起步的分数为10分。
某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？
如果把答对的记为1，答错的记为0，则10个题目的回答情况可以用仅含有1和0的串来表示。例如：0010110011 就是可能的情况。
你的任务是算出所有可能情况。每个答案占一行。

#### [相关知识(二进制位的运算.>>.&)：](https://blog.csdn.net/sugarbliss/article/details/81099340)

```c++
#include <iostream>
#include <stack>
using namespace std;
void b(int a){  //十进制转二进制
    stack<int> s;
    for(int i=0;i<10;i++){
        s.push(a%2);
        a/=2;
    }
    for(int i=0;i<10;i++){
        if(!s.empty()){
            cout<<s.top();
            s.pop();
        }
    }
}
int main()
{
    for(int i=0;i<(1<<10);i++){ //二进制枚举算法     a << b就表示把a转为二进制后左移b位（在后面添b个0）
        int s=10;
        for(int j=9;j>=0;j--){
            if((i&(1<<j))==0){
                s-=(10-j);
            }else{
                s*=2;
            }
        }
        if(s==100){
            b(i);
            cout<<endl;
        }
    }
    return 0;
}
```

## 算法技巧

### 1.依次间隔空格输出，最后一个不加空格

```c++
cout << a % 10 << " ";
cout << '\b'，或 cout << endl;  //最后去掉空格或者换行
```

